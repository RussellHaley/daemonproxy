#! /usr/bin/env perl

use strict;
use warnings;

my @states;
my %commands;

while (<STDIN>) {
	if ($_ =~ m|^\s*STATE\s*\(\s*(\S+)\s*(?:,\s*"(\S+)"\s*)?\)|) {
		push @states, { fn => $1, cmd => $2 };
		$commands{$2}= $states[-1]
			if defined $2;
	}
}

# table size is 1.5 x number of entries rounded up to power of 2.
my $mask= int(1.7 * keys %commands);
$mask |= $mask >> 1;
$mask |= $mask >> 2;
$mask |= $mask >> 4;
$mask |= $mask >> 8;
$mask |= $mask >> 16;
my $table_size= $mask+1;

sub hash_fn {
	my ($string, $shift, $mul)= @_;
	use integer;
	my $result= 0;
	$result= ($result << $shift) ^ (($result >> 24)&0xFF) ^ $_
		for unpack( 'C' x length($string), $string );
	#printf STDERR "%16X\n", $result*$mul;
	return ($result * $mul) & $mask;
}

sub find_collisionless_hash_params {
	# pick factors for the hash function until each command has a unique bucket
	mul_loop: for (my $mul= 1; $mul < 100000; $mul += 2) {
		shift_loop: for (my $shift= 1; $shift < 14; $shift++) {
			my @table= (undef) x $table_size;
			for (values %commands) {
				my $bucket= hash_fn($_->{cmd}, $shift, $mul);
				if (defined $table[$bucket]) {
					#print STDERR join(' ', map { $_ == $bucket? 2 : $table[$_]? 1 : '-' } 0..($table_size-1))."\n";
					next shift_loop;
				}
				$table[$bucket]= $_;
			}
			return ( \@table, $shift, $mul );
		}
	}
	die "No value of \$shift / \$mul results in unique codes for each command\n";
}

my ($table, $shift, $mul)= find_collisionless_hash_params();

my $state_cases= join("\n", map {
	qq|	if (fn == $_->{fn}) return "$_->{fn}";|
	} @states );
my $n_cmd= keys %commands;
my $table_items= join("\n", map {
	$_? qq|	{ "$_->{cmd}", $_->{fn} },| : qq|	{ "", NULL },|
	} @$table );

print <<END;
// File generated by $0

const char *ctl_get_state_name(ctl_state_fn_t *fn) {
$state_cases
	return "invalid state";
}

// table size is $table_size
// $n_cmd commands
// shift is $shift
// mul is $mul

int ctl_command_hash_func(const char* buffer) {
	int x= 0;
	const char *p= buffer;
	while (*p && *p != '\\t') {
		x= (x << $shift) ^ ((x >> 24) & 0xFF) ^ (*p++ & 0xFF);
	}
	return ($mul == 1? x : x * $mul) & $mask;
}

const ctl_command_table_entry_t ctl_command_table[]= {
$table_items
	{NULL, NULL}
};
END
