#! /usr/bin/env perl

use strict;
use warnings;

my @states;
my %commands;

while (<STDIN>) {
	# Look for STATE macros
	push @states, $1
		if ($_ =~ m|^\s*STATE\s*\(\s*(\S+)\s*\)|);
	# Look for COMMAND(fn, "name")
	$commands{$2}= $1
		if ($_ =~ m|^\s*COMMAND\s*\(\s*(\S+)\s*,\s*"(\S+)"\s*\)|);
}

# table size is 1.5 x number of entries rounded up to power of 2.
my $mask= int(1.75 * keys %commands);
$mask |= $mask >> 1;
$mask |= $mask >> 2;
$mask |= $mask >> 4;
$mask |= $mask >> 8;
$mask |= $mask >> 16;
my $table_size= $mask+1;

sub hash_fn {
	my ($string, $mul, $shift)= @_;
	use integer;
	my $i32_mask= (1<<(32-$shift))-1;
	my $result= 0;
	$result= ((($result * $mul) >> $shift) & $i32_mask) + $_
		for unpack( 'C' x length($string), $string );
	return $result & $mask;
}

sub build_table {
	my ($mul, $shift)= @_;
	my @table= (undef) x $table_size;
	for my $k (keys %commands) {
		my $bucket= hash_fn($k, $mul, $shift);
		if (defined $table[$bucket]) {
#			print STDERR join(' ', map { $_ == $bucket? 2 : $table[$_]? 1 : '-' } 0..($table_size-1))."\n";
			return undef;
		}
		$table[$bucket]= $k;
	}
	return \@table;
}

sub find_collisionless_hash_params {
	# pick factors for the hash function until each command has a unique bucket
	for (my $mul= 1; $mul < $table_size*$table_size; $mul++) {
		for (my $shift= 0; $shift < 11; $shift++) {
			my $table= build_table($mul, $shift);
			return ( $table, $mul, $shift )
				if $table;
		}
	}
	die "No value of \$shift / \$mul results in unique codes for each command\n";
}

my ($table, $mul, $shift)= find_collisionless_hash_params();

my $state_cases= join("\n", map {
	qq|	if (fn == $_) return "$_";|
	} @states );
my $n_cmd= keys %commands;
my $table_items= join("\n", map {
	defined $_? qq|	{ { "$_", |.length($_).qq|}, $commands{$_} },| : qq|	{ { NULL, 0 }, NULL },|
	} @$table );

print <<END;
// File generated by $0

const char *ctl_get_state_name(ctl_state_fn_t *fn) {
$state_cases
	return "invalid state";
}

// $n_cmd commands
// table size is $table_size, mul is $mul, shift is $shift

int ctl_command_hash_func(strseg_t name) {
	uint32_t x= 0;
	int i= 0;
	for (i= 0; i < name.len; i++)
		x= ((x * $mul) >> $shift) + (name.data[i] & 0xFF);
	
	return x & $mask;
}

const ctl_command_table_entry_t ctl_command_table[]= {
$table_items
	{ {NULL, 0}, NULL}
};
END
